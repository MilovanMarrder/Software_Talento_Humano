ESTE ES EL CONTEXTO ACTUAL DEL PROYECTO RRHH HMEP.
Stack: Python 3.13 + Tkinter (ttkbootstrap) + SQLite.
Patrón: MVC Modular + Lógica de Negocio separada.

## Estructura del Proyecto
```
./
    backfill_dni_perc.py
    context_prompt.py
    main.py
    migration.py
    migrations_deptos_puestos.py
    migration_puestos.py
    assets/
    config/
        db_connection.py
        settings.py
        __init__.py
    controllers/
        __init__.py
    logics/
        perc_export_service.py
        report_service.py
        time_calculator.py
        vacation_service.py
        __init__.py
    models/
        attendance_dao.py
        catalogs_dao.py
        contract_dao.py
        employee_dao.py
        kardex_dao.py
        __init__.py
    views/
        main_window.py
        styles.py
        __init__.py
        components/
            contract_selector.py
            employee_selector.py
        modules/
            attendance_view.py
            configuration_view.py
            contracts_view.py
            employees_view.py
            reports_view.py
            vacation_balance_view.py
            __init__.py
```

# --- ARCHIVOS CORE (Estructura/Config) ---

## Archivo: main.py
```python
import ttkbootstrap as ttk
from config.db_connection import DatabaseConnection
from views.main_window import MainWindow
from config import settings 

class App(ttk.Window):
    def __init__(self):
        # Configuración inicial de la ventana
        # Themes claros recomendados: 'flatly', 'litera', 'yeti'
        # Themes oscuros recomendados: 'darkly', 'superhero'
        super().__init__(themename="flatly")
        
        
        # Usamos las variables centralizadas están en settings dentro de config
        self.title(settings.APP_TITLE)
        self.geometry(settings.APP_SIZE)
        
        # Configuración del Icono Principal
        if settings.ICON_PATH.exists():
            self.iconbitmap(settings.ICON_PATH)
        else:
            print(f"⚠ No se encontró el icono en: {settings.ICON_PATH}")


        # 1. Validar Base de Datos al inicio
        self.db = DatabaseConnection()
        if not self.db.test_connection():
            print("⚠ ADVERTENCIA: No se pudo conectar a la base de datos.")
            # Aquí podrías lanzar un popup de error antes de cerrar
        
        # 2. Inicializar Vista Principal
        # Pasamos 'self' como controller temporalmente
        self.main_window = MainWindow(self, controller=self)
        
    def run(self):
        self.mainloop()

if __name__ == "__main__":
    app = App()
    app.run()
```

## Archivo: config/settings.py
```python
import os
from pathlib import Path

# Definimos la raíz del proyecto (basado en la ubicación de este archivo)
# Subimos un nivel desde 'config' para llegar a la raíz
BASE_DIR = Path(__file__).resolve().parent.parent

# Ruta absoluta a los assets
ASSETS_DIR = BASE_DIR / "assets"

# Nombre de base de datos
DB_NAME = "rrhh.db"

# ruta de base de datos
DB_PATH = BASE_DIR / DB_NAME

# Ruta centralizada del Icono
ICON_PATH = ASSETS_DIR / "blowfish_icon.ico"

# Constantes de la App
APP_TITLE = "Sistema de Talento Humano HMEP"
APP_SIZE = "1100x650" # Un poco más grande para comodidad
```

## Archivo: config/db_connection.py
```python
import sqlite3
import os
from pathlib import Path
from config import settings 

class DatabaseConnection:
    """
    Manejador de conexión a la base de datos SQLite.
    Implementa el patrón Context Manager (with statement) si se desea,
    o métodos directos.
    """
    
    def __init__(self, db_name=settings.DB_NAME):
        # Obtiene la ruta absoluta del directorio raíz del proyecto
        # Asume que este archivo está en /config/ y subimos un nivel
        self.root_dir = Path(__file__).parent.parent
        self.db_path = self.root_dir / db_name

    def get_connection(self):
        """Retorna una conexión activa con FKs habilitadas."""
        try:
            conn = sqlite3.connect(self.db_path)
            # CRÍTICO: SQLite por defecto tiene las FK desactivadas. 
            # Esto evita que insertes inasistencias sin contrato.
            conn.execute("PRAGMA foreign_keys = ON") 
            return conn
        except sqlite3.Error as e:
            print(f"Error conectando a la BD en {self.db_path}: {e}")
            return None

    def test_connection(self):
        """Método helper para probar si la DB existe y responde."""
        conn = self.get_connection()
        if conn:
            print(f"✅ Conexión exitosa a: {self.db_path}")
            conn.close()
            return True
        else:
            print("❌ Fallo en la conexión.")
            return False
```
[MISSING FILE: migrations_perc.py]
[MISSING FILE: migrations_puestos.py]

# --- ARCHIVOS DE TRABAJO ACTUAL (Foco) ---

## Archivo: models/contract_dao.py
```python
import sqlite3
from config.db_connection import DatabaseConnection

class ContractDAO:
    def __init__(self):
        self.db = DatabaseConnection()

    # Añadir este método helper dentro de la clase ContractDAO
    def _sync_initial_balance_kardex(self, cursor, id_contrato, fecha_kardex, dias_iniciales):
        """Inserta o actualiza el registro de SALDO_INICIAL en el Kardex"""
        # 1. Verificar si ya existe un saldo inicial
        cursor.execute("""
            SELECT id_movimiento FROM kardex_vacaciones 
            WHERE id_contrato = ? AND tipo_movimiento = 'SALDO_INICIAL'
        """, (id_contrato,))
        row = cursor.fetchone()

        obs = f"Saldo Inicial al corte {fecha_kardex}"
        
        if row:
            # Actualizar existente
            cursor.execute("""
                UPDATE kardex_vacaciones 
                SET dias = ?, fecha_movimiento = ?, observacion = ?
                WHERE id_movimiento = ?
            """, (dias_iniciales, fecha_kardex, obs, row[0]))
        else:
            # Insertar nuevo
            if dias_iniciales > 0: # Solo si hay saldo
                cursor.execute("""
                    INSERT INTO kardex_vacaciones (id_contrato, fecha_movimiento, tipo_movimiento, dias, observacion)
                    VALUES (?, ?, 'SALDO_INICIAL', ?, ?)
                """, (id_contrato, fecha_kardex, dias_iniciales, obs))

# --- MÉTODO HELPER INTERNO ---
    def _calculate_dni_perc(self, cursor, id_empleado, id_tipo_contrato):
        """
        Calcula el DNI PERC basado en la regla de negocio:
        - HMEP -> DNI Limpio
        - OTROS -> DNI + Primera Letra del Tipo Contrato
        """
        # 1. Obtener DNI del empleado
        cursor.execute("SELECT dni FROM empleados WHERE id_empleado = ?", (id_empleado,))
        row_emp = cursor.fetchone()
        dni = row_emp[0] if row_emp else ""
        
        # 2. Obtener Nombre del Tipo de Contrato
        cursor.execute("SELECT nombre FROM cat_tipos_contrato WHERE id_tipo_contrato = ?", (id_tipo_contrato,))
        row_tipo = cursor.fetchone()
        nombre_tipo = row_tipo[0] if row_tipo else ""
        
        # 3. Aplicar Lógica
        nombre_upper = nombre_tipo.upper().strip()
        if "HMEP" in nombre_upper:
            return dni
        else:
            suffix = nombre_upper[0] if nombre_upper else "X"
            return f"{dni}{suffix}"

    # --- CREATE ACTUALIZADO ---
    def create_contract(self, data_contrato, lista_costos):
        conn = self.db.get_connection()
        try:
            cursor = conn.cursor()
            
            # Desempaquetar
            (id_emp, id_puesto, id_depto, id_tipo, id_jornada, 
             f_kardex, s_inicial, f_ini, f_fin, salario) = data_contrato

            # 1. CALCULAR DNI PERC AUTOMÁTICO
            dni_perc = self._calculate_dni_perc(cursor, id_emp, id_tipo)

            query = """
                INSERT INTO contratos 
                (id_empleado, id_puesto, id_departamento, id_tipo_contrato, id_jornada, 
                 fecha_inicio_kardex, saldo_inicial_vacaciones,
                 fecha_inicio, fecha_fin, salario, 
                 dni_perc, activo)  -- <-- Agregado dni_perc
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, 1)
            """
            cursor.execute(query, (id_emp, id_puesto, id_depto, id_tipo, id_jornada, 
                                   f_kardex, s_inicial, f_ini, f_fin, salario, dni_perc))
            
            id_contrato = cursor.lastrowid
            
            # Insertar Costos
            for uid, pct in lista_costos:
                cursor.execute("INSERT INTO distribucion_costos (id_contrato, id_unidad, porcentaje) VALUES (?, ?, ?)", (id_contrato, uid, pct))
            
            # Sincronizar Kardex
            if f_kardex:
                self._sync_initial_balance_kardex(cursor, id_contrato, f_kardex, s_inicial)

            conn.commit()
            return True, "Contrato creado."
        except Exception as e:
            conn.rollback()
            return False, f"Error: {e}"
        finally:
            conn.close()

    # --- UPDATE ACTUALIZADO ---
    def update_contract(self, id_contrato, data_contrato, lista_costos):
        conn = self.db.get_connection()
        try:
            cursor = conn.cursor()
            
            # Data recibida desde la vista (Nota: NO trae id_empleado, hay que buscarlo)
            (id_puesto, id_depto, id_tipo, id_jornada, 
             f_kardex, s_inicial, 
             f_ini, f_fin, salario, _id_con_param) = data_contrato
            
            # 1. RECUPERAR ID_EMPLEADO (Para recalcular dni_perc si cambió el tipo)
            cursor.execute("SELECT id_empleado FROM contratos WHERE id_contrato = ?", (id_contrato,))
            row_emp = cursor.fetchone()
            if not row_emp: raise Exception("Contrato no encontrado")
            id_emp = row_emp[0]

            # 2. RECALCULAR DNI PERC
            dni_perc = self._calculate_dni_perc(cursor, id_emp, id_tipo)

            query = """
                UPDATE contratos 
                SET id_puesto=?, id_departamento=?, id_tipo_contrato=?, id_jornada=?,
                    fecha_inicio_kardex=?, saldo_inicial_vacaciones=?,
                    fecha_inicio=?, fecha_fin=?, salario=?,
                    dni_perc=?   -- <-- Actualizamos esto
                WHERE id_contrato=?
            """
            cursor.execute(query, (id_puesto, id_depto, id_tipo, id_jornada, f_kardex, s_inicial, 
                                   f_ini, f_fin, salario, dni_perc, id_contrato))
            
            # Costos...
            cursor.execute("DELETE FROM distribucion_costos WHERE id_contrato=?", (id_contrato,))
            for uid, pct in lista_costos:
                cursor.execute("INSERT INTO distribucion_costos (id_contrato, id_unidad, porcentaje) VALUES (?, ?, ?)", (id_contrato, uid, pct))

            # Sincronizar Kardex
            if f_kardex:
                self._sync_initial_balance_kardex(cursor, id_contrato, f_kardex, s_inicial)

            conn.commit()
            return True, "Actualizado."
        except Exception as e:
            conn.rollback()
            return False, str(e)
        finally:
            conn.close()


    def delete_contract(self, id_contrato):
            conn = self.db.get_connection()
            try:
                cursor = conn.cursor()
                print(f"DEBUG DAO: Intentando borrar contrato {id_contrato}") # <--- Agrega esto
                
                # 1. Eliminar costos
                cursor.execute("DELETE FROM distribucion_costos WHERE id_contrato = ?", (id_contrato,))
                
                # 2. Eliminar contrato
                cursor.execute("DELETE FROM contratos WHERE id_contrato = ?", (id_contrato,))
                
                if cursor.rowcount == 0:
                    print("DEBUG DAO: No se borró nada (rowcount 0)")
                    
                conn.commit() # <--- ¡CRÍTICO!
                return True, "Contrato eliminado correctamente."
            except Exception as e:
                conn.rollback()
                print(f"DEBUG DAO ERROR: {e}")
                return False, f"No se pudo eliminar: {e}"
            finally:
                conn.close()
            
    def get_employee_by_code(self, codigo):
        """Busca ID y Nombre de empleado por su código"""
        conn = self.db.get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id_empleado, nombres, apellidos FROM empleados WHERE codigo = ? AND activo = 1", (codigo,))
        row = cursor.fetchone()
        conn.close()
        return row
    


    def get_all_contracts(self):
        """Obtiene lista resumen para la tabla inferior"""
        conn = self.db.get_connection()
        cursor = conn.cursor()
        query = """
        SELECT 
            c.id_contrato, 
            e.codigo || ' - ' || e.nombres || ' ' || e.apellidos,
            p.nombre_puesto,
            tc.nombre,
            c.fecha_inicio
        FROM contratos c
        JOIN empleados e ON c.id_empleado = e.id_empleado
        JOIN cat_puestos p ON c.id_puesto = p.id_puesto
        JOIN cat_tipos_contrato tc ON c.id_tipo_contrato = tc.id_tipo_contrato
        WHERE c.activo = 1
        ORDER BY c.id_contrato DESC
        """
        cursor.execute(query)
        rows = cursor.fetchall()
        conn.close()
        return rows

    def get_contract_details(self, id_contrato):
        """Recupera toda la info de un contrato y sus costos para editar"""
        conn = self.db.get_connection()
        cursor = conn.cursor()
        
        # 1. Datos Contrato
        cursor.execute("SELECT * FROM contratos WHERE id_contrato = ?", (id_contrato,))
        contrato = cursor.fetchone()
        
        # 2. Datos Empleado (Para mostrar el nombre en el label)
        cursor.execute("""
            SELECT e.id_empleado, e.codigo, e.nombres, e.apellidos 
            FROM empleados e 
            JOIN contratos c ON e.id_empleado = c.id_empleado 
            WHERE c.id_contrato = ?
        """, (id_contrato,))
        empleado = cursor.fetchone()
        
        # 3. Distribución Costos (Join para traer nombre de unidad)
        cursor.execute("""
            SELECT dc.id_unidad, up.nombre_up, dc.porcentaje
            FROM distribucion_costos dc
            JOIN cat_unidades_produccion up ON dc.id_unidad = up.id_unidad
            WHERE dc.id_contrato = ?
        """, (id_contrato,))
        costos = cursor.fetchall()
        
        conn.close()
        return contrato, empleado, costos
    
# ... (métodos anteriores)

    def search_contracts(self, term):
        """
        Busca contratos por Nombre de Empleado, Código, DNI o Puesto.
        Optimizado para el Selector.
        """
        conn = self.db.get_connection()
        cursor = conn.cursor()
        search_term = f"%{term}%"
        
        query = """
        SELECT 
            c.id_contrato, 
            e.codigo || ' - ' || e.nombres || ' ' || e.apellidos as empleado,
            p.nombre_puesto,
            tc.nombre as tipo,
            c.fecha_inicio,
            CASE WHEN c.activo = 1 THEN 'Activo' ELSE 'Inactivo' END as estado
        FROM contratos c
        JOIN empleados e ON c.id_empleado = e.id_empleado
        JOIN cat_puestos p ON c.id_puesto = p.id_puesto
        JOIN cat_tipos_contrato tc ON c.id_tipo_contrato = tc.id_tipo_contrato
        WHERE 
            e.nombres LIKE ? OR 
            e.apellidos LIKE ? OR 
            e.codigo LIKE ? OR 
            e.dni LIKE ? OR
            p.nombre_puesto LIKE ?
        ORDER BY c.activo DESC, c.fecha_inicio DESC
        LIMIT 50 -- Límite de seguridad para no saturar UI
        """
        # Repetimos el término para cada ?
        params = (search_term, search_term, search_term, search_term, search_term)
        cursor.execute(query, params)
        rows = cursor.fetchall()
        conn.close()
        return rows
```

## Archivo: models/catalogs_dao.py
```python
import sqlite3
from config.db_connection import DatabaseConnection

class CatalogsDAO:
    def __init__(self):
        self.db = DatabaseConnection()

    # --- GENÉRICOS DE LECTURA ---
    def get_departamentos(self):
        return self._get_all("cat_departamentos", "id_departamento", "nombre") # Retorna (id, nombre, codigo)

    def get_puestos(self):
        # Necesitamos un join o selección específica para mostrar datos ricos
        conn = self.db.get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id_puesto, nombre_puesto FROM cat_puestos ORDER BY nombre_puesto")
        rows = cursor.fetchall()
        conn.close()
        return rows

    def get_tipos_contrato(self):
        return self._get_all("cat_tipos_contrato", "id_tipo_contrato", "nombre")

    def get_unidades_produccion(self):
        # Retorna (id, nombre_up, codigo_up)
        conn = self.db.get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id_unidad, nombre_up, codigo_up FROM cat_unidades_produccion ORDER BY nombre_up")
        rows = cursor.fetchall()
        conn.close()
        return rows

    def _get_all(self, table, id_col, sort_col):
        conn = self.db.get_connection()
        cursor = conn.cursor()
        try:
            # Nota: SELECT * asume orden de columnas. 
            # Para deptos: id, nombre, codigo_interno
            cursor.execute(f"SELECT * FROM {table} ORDER BY {sort_col}")
            return cursor.fetchall()
        finally:
            conn.close()

    # --- CRUD DEPARTAMENTOS ---
    def crud_departamento(self, action, id_item=None, nombre=None, codigo=None):
        conn = self.db.get_connection()
        try:
            cursor = conn.cursor()
            if action == 'INSERT':
                cursor.execute("INSERT INTO cat_departamentos (nombre, codigo_interno) VALUES (?, ?)", (nombre, codigo))
            elif action == 'UPDATE':
                cursor.execute("UPDATE cat_departamentos SET nombre=?, codigo_interno=? WHERE id_departamento=?", (nombre, codigo, id_item))
            elif action == 'DELETE':
                cursor.execute("DELETE FROM cat_departamentos WHERE id_departamento=?", (id_item,))
            conn.commit()
            return True, "Operación exitosa"
        except sqlite3.IntegrityError as e:
            return False, f"Error de integridad (¿Registro en uso?): {e}"
        except Exception as e:
            return False, f"Error: {e}"
        finally:
            conn.close()

    # --- CRUD UNIDADES PRODUCCION ---
    def crud_unidad(self, action, id_item=None, nombre=None, codigo=None):
        conn = self.db.get_connection()
        try:
            cursor = conn.cursor()
            if action == 'INSERT':
                cursor.execute("INSERT INTO cat_unidades_produccion (nombre_up, codigo_up) VALUES (?, ?)", (nombre, codigo))
            elif action == 'UPDATE':
                cursor.execute("UPDATE cat_unidades_produccion SET nombre_up=?, codigo_up=? WHERE id_unidad=?", (nombre, codigo, id_item))
            elif action == 'DELETE':
                cursor.execute("DELETE FROM cat_unidades_produccion WHERE id_unidad=?", (id_item,))
            conn.commit()
            return True, "Operación exitosa"
        except sqlite3.IntegrityError:
            return False, "No se puede eliminar: La unidad tiene costos asociados en contratos."
        except Exception as e:
            return False, f"Error: {e}"
        finally:
            conn.close()

# ... (Dentro de CatalogsDAO) ...

    # --- NUEVOS MÉTODOS HELPER ---
    
    def get_grupos_perc_combo(self):
        """Retorna (id, codigo - descripcion) para el combobox"""
        conn = self.db.get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id_grupo, codigo || ' - ' || descripcion FROM cat_grupos_perc ORDER BY codigo")
        rows = cursor.fetchall()
        conn.close()
        return rows

    def get_puestos_jefatura_combo(self):
        """Retorna solo los puestos marcados como jefatura"""
        conn = self.db.get_connection()
        cursor = conn.cursor()
        # Traemos todos los puestos que tienen personal a cargo
        cursor.execute("SELECT id_puesto, nombre_puesto FROM cat_puestos WHERE tiene_personal_cargo = 1 ORDER BY nombre_puesto")
        rows = cursor.fetchall()
        conn.close()
        return rows

    # PUESTOS
    def get_puestos(self):
        """
        Retorna datos enriquecidos.
        Orden Visual: 
          0.ID, 
          1.Nombre, 
          2.Departamento (NUEVO), 
          3.¿Es Jefe?, 
          4.Reporta A, 
          5.Grupo PERC
        
        Datos Raw (Indices ocultos para edición):
          6. id_departamento (NUEVO)
          7. tiene_personal_cargo
          8. id_puesto_jefe
          9. id_grupo_perc
        """
        conn = self.db.get_connection()
        cursor = conn.cursor()
        query = """
            SELECT 
                p.id_puesto, 
                p.nombre_puesto,
                COALESCE(d.nombre, '---') as depto_nombre, -- Visual
                CASE WHEN p.tiene_personal_cargo = 1 THEN 'Sí' ELSE 'No' END as es_jefe,
                COALESCE(jefe.nombre_puesto, '---') as reporta_a,
                COALESCE(gp.codigo || ' - ' || gp.descripcion, '---') as grupo_perc,
                
                -- RAW DATA
                p.id_departamento,      -- Index 6
                p.tiene_personal_cargo, -- Index 7
                p.id_puesto_jefe,       -- Index 8
                p.id_grupo_perc         -- Index 9
            FROM cat_puestos p
            LEFT JOIN cat_departamentos d ON p.id_departamento = d.id_departamento
            LEFT JOIN cat_puestos jefe ON p.id_puesto_jefe = jefe.id_puesto
            LEFT JOIN cat_grupos_perc gp ON p.id_grupo_perc = gp.id_grupo
            ORDER BY p.nombre_puesto
        """
        cursor.execute(query)
        rows = cursor.fetchall()
        conn.close()
        return rows

    def crud_puesto(self, action, id_item=None, nombre=None, 
                    id_depto=None,  # NUEVO PARAM
                    tiene_personal=0, id_jefe=None, id_grupo_perc=None, id_tipo=1):
        
        conn = self.db.get_connection()
        try:
            cursor = conn.cursor()
            
            # Sanitización de Nulos
            if not id_jefe: id_jefe = None
            if not id_grupo_perc: id_grupo_perc = None
            if not id_depto: id_depto = None # <-- Importante
            tiene_personal = 1 if tiene_personal else 0

            if action == 'INSERT':
                cursor.execute("""
                    INSERT INTO cat_puestos 
                    (nombre_puesto, id_departamento, tiene_personal_cargo, id_puesto_jefe, id_grupo_perc, id_tipo_puesto) 
                    VALUES (?, ?, ?, ?, ?, ?)
                """, (nombre, id_depto, tiene_personal, id_jefe, id_grupo_perc, 1))
                
            elif action == 'UPDATE':
                if id_jefe and id_item and int(id_jefe) == int(id_item):
                    return False, "Referencia circular en Jefatura."

                cursor.execute("""
                    UPDATE cat_puestos 
                    SET nombre_puesto=?, id_departamento=?, tiene_personal_cargo=?, id_puesto_jefe=?, id_grupo_perc=? 
                    WHERE id_puesto=?
                """, (nombre, id_depto, tiene_personal, id_jefe, id_grupo_perc, id_item))
                
            elif action == 'DELETE':
                cursor.execute("DELETE FROM cat_puestos WHERE id_puesto=?", (id_item,))
            
            conn.commit()
            return True, "Operación exitosa"
        except sqlite3.IntegrityError:
            return False, "Error de Integridad."
        except Exception as e:
            return False, f"Error: {e}"
        finally:
            conn.close()

# --- NUEVO: CRUD CATEGORÍAS INASISTENCIA (MACRO) ---
    def get_categorias_inasistencia(self):
        # Retorna: (id, nombre)
        return self._get_all("cat_categorias_inasistencia", "id_categoria", "nombre_categoria")

    def crud_categoria_inasistencia(self, action, id_item=None, nombre=None):
        conn = self.db.get_connection()
        try:
            cursor = conn.cursor()
            if action == 'INSERT':
                cursor.execute("INSERT INTO cat_categorias_inasistencia (nombre_categoria) VALUES (?)", (nombre,))
            elif action == 'UPDATE':
                cursor.execute("UPDATE cat_categorias_inasistencia SET nombre_categoria=? WHERE id_categoria=?", (nombre, id_item))
            elif action == 'DELETE':
                cursor.execute("DELETE FROM cat_categorias_inasistencia WHERE id_categoria=?", (id_item,))
            conn.commit()
            return True, "Operación exitosa"
        except sqlite3.IntegrityError:
            return False, "No se puede eliminar: Hay tipos de falta vinculados a esta categoría."
        except Exception as e:
            return False, f"Error: {e}"
        finally:
            conn.close()


    # --- CRUD TIPOS INASISTENCIA (SIMPLIFICADO) ---
    def get_tipos_inasistencia(self):
        # Retorna datos para la tabla y el formulario
        conn = self.db.get_connection()
        cursor = conn.cursor()
        # Traemos 'cuenta_afectada' que ya existe en la BD por la migración
        query = """
            SELECT 
                t.id_tipo, 
                t.nombre_tipo, 
                c.nombre_categoria,
                CASE 
                    WHEN t.cuenta_afectada = 'ORDINARIA' THEN 'Sí' 
                    ELSE 'No' 
                END as descuenta_saldo, -- Visualmente mostramos Sí/No
                t.id_categoria,
                t.cuenta_afectada       -- Raw para el formulario
            FROM cat_tipos_inasistencia t
            JOIN cat_categorias_inasistencia c ON t.id_categoria = c.id_categoria
            ORDER BY c.nombre_categoria, t.nombre_tipo
        """
        cursor.execute(query)
        rows = cursor.fetchall()
        conn.close()
        return rows

    def crud_tipo_inasistencia(self, action, id_item=None, nombre=None, id_cat=None, cuenta_afectada='NINGUNA', remunerado=0):
            conn = self.db.get_connection()
            try:
                cursor = conn.cursor()
                
                # Asegurar que remunerado sea 0 o 1 (SQLite no tiene bool nativo estricto)
                remunerado = int(remunerado) if remunerado else 0

                if action == 'INSERT':
                    cursor.execute("""
                        INSERT INTO cat_tipos_inasistencia (nombre_tipo, id_categoria, cuenta_afectada, remunerado) 
                        VALUES (?, ?, ?, ?)
                    """, (nombre, id_cat, cuenta_afectada, remunerado))
                
                elif action == 'UPDATE':
                    cursor.execute("""
                        UPDATE cat_tipos_inasistencia 
                        SET nombre_tipo=?, id_categoria=?, cuenta_afectada=?, remunerado=? 
                        WHERE id_tipo=?
                    """, (nombre, id_cat, cuenta_afectada, remunerado, id_item))
                
                elif action == 'DELETE':
                    cursor.execute("DELETE FROM cat_tipos_inasistencia WHERE id_tipo=?", (id_item,))
                
                conn.commit()
                return True, "Operación exitosa"
            except Exception as e:
                return False, f"Error: {e}"
            finally:
                conn.close()

    # --- CRUD TIPOS DE CONTRATO ---
    def crud_tipo_contrato(self, action, id_item=None, nombre=None):
        conn = self.db.get_connection()
        try:
            cursor = conn.cursor()
            if action == 'INSERT':
                cursor.execute("INSERT INTO cat_tipos_contrato (nombre) VALUES (?)", (nombre,))
            elif action == 'UPDATE':
                cursor.execute("UPDATE cat_tipos_contrato SET nombre=? WHERE id_tipo_contrato=?", (nombre, id_item))
            elif action == 'DELETE':
                cursor.execute("DELETE FROM cat_tipos_contrato WHERE id_tipo_contrato=?", (id_item,))
            conn.commit()
            return True, "Operación exitosa"
        except sqlite3.IntegrityError:
            return False, "No se puede eliminar: Existen contratos activos bajo esta modalidad."
        except Exception as e:
            return False, f"Error: {e}"
        finally:
            conn.close()


    # --- CRUD JORNADAS ---
    def get_jornadas(self):
        # (id, nombre, horas)
        return self._get_all("cat_jornadas", "id_jornada", "nombre")

    def crud_jornada(self, action, id_item=None, nombre=None, horas=8.0):
        conn = self.db.get_connection()
        try:
            cursor = conn.cursor()
            if action == 'INSERT':
                cursor.execute("INSERT INTO cat_jornadas (nombre, horas_diarias) VALUES (?, ?)", (nombre, horas))
            elif action == 'UPDATE':
                cursor.execute("UPDATE cat_jornadas SET nombre=?, horas_diarias=? WHERE id_jornada=?", (nombre, horas, id_item))
            elif action == 'DELETE':
                cursor.execute("DELETE FROM cat_jornadas WHERE id_jornada=?", (id_item,))
            conn.commit()
            return True, "Operación exitosa"
        except sqlite3.IntegrityError:
            return False, "No se puede eliminar: Jornada asignada a contratos."
        except Exception as e:
            return False, str(e)
        finally:
            conn.close()

    # --- CRUD REGLAS VACACIONES ---
    def get_reglas_vacaciones(self):
        conn = self.db.get_connection()
        cursor = conn.cursor()
        query = """
            SELECT 
                r.id_regla, 
                ti.nombre_tipo || ' (' || c.nombre_categoria || ')',
                r.anios_antiguedad,
                r.dias_otorgar,
                r.id_tipo_inasistencia -- Raw para edición
            FROM cat_reglas_vacaciones r
            JOIN cat_tipos_inasistencia ti ON r.id_tipo_inasistencia = ti.id_tipo
            JOIN cat_categorias_inasistencia c ON ti.id_categoria = c.id_categoria
            ORDER BY ti.nombre_tipo, r.anios_antiguedad
        """
        cursor.execute(query)
        rows = cursor.fetchall()
        conn.close()
        return rows

    def crud_regla_vacacion(self, action, id_item=None, id_tipo_inasistencia=None, anios=None, dias=None):
        conn = self.db.get_connection()
        try:
            cursor = conn.cursor()
            if action == 'INSERT':
                cursor.execute("INSERT INTO cat_reglas_vacaciones (id_tipo_inasistencia, anios_antiguedad, dias_otorgar) VALUES (?, ?, ?)", 
                               (id_tipo_inasistencia, anios, dias))
            elif action == 'UPDATE':
                cursor.execute("UPDATE cat_reglas_vacaciones SET id_tipo_inasistencia=?, anios_antiguedad=?, dias_otorgar=? WHERE id_regla=?", 
                               (id_tipo_inasistencia, anios, dias, id_item))
            elif action == 'DELETE':
                cursor.execute("DELETE FROM cat_reglas_vacaciones WHERE id_regla=?", (id_item,))
            conn.commit()
            return True, "Operación exitosa"
        except Exception as e:
            return False, str(e)
        finally:
            conn.close()

    def get_only_vacation_types_combo(self):
        """Retorna solo los tipos de inasistencia marcados como 'descuenta_vacaciones'"""
        conn = self.db.get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id_tipo, nombre_tipo FROM cat_tipos_inasistencia WHERE descuenta_vacaciones = 1")
        rows = cursor.fetchall()
        conn.close()
        return rows
```
[MISSING FILE: models/attendace_dao.py]

## Archivo: models/employee_dao.py
```python
import sqlite3
from config.db_connection import DatabaseConnection

class EmployeeDAO:
    def __init__(self):
        self.db = DatabaseConnection()

    def insert(self, codigo, dni, nombres, apellidos, fecha_nac, activo=1):
            conn = self.db.get_connection()
            try:
                # 1. SANITIZACIÓN (Limpieza de datos)
                # Convertimos cadenas vacías "" a None (NULL en SQL)
                # Esto es vital porque para SQLite "" es un valor y puede duplicarse, 
                # pero si tu restricción UNIQUE choca, mejor manejarlo como NULL.
                dni_final = dni.strip() if dni and dni.strip() else None
                codigo_final = codigo.strip()
                
                # 2. INTENTO DE GUARDADO
                query = """
                    INSERT INTO empleados (codigo, dni, nombres, apellidos, fecha_nacimiento, activo)
                    VALUES (?, ?, ?, ?, ?, ?)
                """
                cursor = conn.cursor()
                cursor.execute(query, (codigo_final, dni_final, nombres, apellidos, fecha_nac, activo))
                conn.commit()
                
                # Si llegamos aquí, se guardó.
                print(f"DEBUG: Empleado {codigo_final} guardado exitosamente en BD.")
                return True, "Empleado guardado exitosamente."
                
            except sqlite3.IntegrityError as e:
                # Esto solo salta si NO se pudo guardar
                err_msg = str(e)
                print(f"DEBUG SQL ERROR: {err_msg}")
                
                if "UNIQUE constraint failed" in err_msg:
                    if "empleados.codigo" in err_msg:
                        return False, f"El Código '{codigo}' ya existe."
                    elif "empleados.dni" in err_msg:
                        return False, f"El DNI '{dni}' ya existe."
                    return False, "El registro ya existe (Código o DNI duplicado)."
                
                return False, f"Error de integridad: {err_msg}"
                
            except Exception as e:
                print(f"DEBUG EXCEPTION: {e}")
                return False, f"Error desconocido: {e}"
            finally:
                conn.close()

    def update(self, id_empleado, codigo, dni, nombres, apellidos, fecha_nac):
        """Actualiza un registro existente"""
        conn = self.db.get_connection()
        try:
            query = """
                UPDATE empleados 
                SET codigo=?, dni=?, nombres=?, apellidos=?, fecha_nacimiento=?
                WHERE id_empleado=?
            """
            cursor = conn.cursor()
            cursor.execute(query, (codigo, dni, nombres, apellidos, fecha_nac, id_empleado))
            conn.commit()
            return True, "Empleado actualizado correctamente."
        except sqlite3.IntegrityError:
            return False, "No se puede actualizar: El Código o DNI pertenecen a otro empleado."
        except Exception as e:
            return False, f"Error al actualizar: {e}"
        finally:
            conn.close()

    def get_all(self):

        conn = self.db.get_connection()
        cursor = conn.cursor()
        cursor.execute("SELECT id_empleado, codigo, dni, nombres, apellidos, fecha_nacimiento FROM empleados WHERE activo = 1")
        rows = cursor.fetchall()
        conn.close()
        return rows
```

## Archivo: models/kardex_dao.py
```python
import sqlite3
from config.db_connection import DatabaseConnection

class KardexDAO:
    def __init__(self):
        self.db = DatabaseConnection()

    def get_kardex_report(self, id_contrato, fecha_inicio=None, fecha_fin=None):
            conn = self.db.get_connection()
            cursor = conn.cursor()

            # 1. Calcular SALDO INICIAL
            # CORRECCIÓN CRÍTICA: Solo calculamos saldo inicial si hay una fecha de corte.
            # Si fecha_inicio es None, queremos ver toda la historia, por ende el saldo inicial es 0.
            saldo_inicial = 0.0
            
            if fecha_inicio:
                query_saldo = """
                    SELECT COALESCE(SUM(dias), 0) FROM kardex_vacaciones 
                    WHERE id_contrato = ? 
                    AND (cuenta_tipo = 'ORDINARIA' OR cuenta_tipo IS NULL)
                    AND fecha_movimiento < ?
                """
                cursor.execute(query_saldo, (id_contrato, fecha_inicio))
                result = cursor.fetchone()
                if result:
                    saldo_inicial = result[0]

            # 2. Obtener MOVIMIENTOS
            query_movs = """
                SELECT 
                    k.id_movimiento,
                    k.fecha_movimiento,
                    k.tipo_movimiento,
                    k.observacion,
                    k.dias,
                    i.fecha_inicio_real,
                    i.fecha_fin_real
                FROM kardex_vacaciones k
                LEFT JOIN inasistencias i ON k.id_referencia = i.id_inasistencia
                WHERE k.id_contrato = ?
                AND (k.cuenta_tipo = 'ORDINARIA' OR k.cuenta_tipo IS NULL)
            """
            params = [id_contrato]

            if fecha_inicio:
                query_movs += " AND k.fecha_movimiento >= ?"
                params.append(fecha_inicio)
            
            if fecha_fin:
                query_movs += " AND k.fecha_movimiento <= ?"
                params.append(fecha_fin)

            query_movs += " ORDER BY k.fecha_movimiento ASC, k.id_movimiento ASC"

            cursor.execute(query_movs, params)
            movimientos = cursor.fetchall()
            
            conn.close()
            return saldo_inicial, movimientos

    def add_manual_movement(self, id_contrato, tipo, dias, obs):
        """Permite agregar saldo inicial o ajustes manuales desde la vista de saldos"""
        conn = self.db.get_connection()
        try:
            cursor = conn.cursor()
            cursor.execute("""
                INSERT INTO kardex_vacaciones (id_contrato, fecha_movimiento, tipo_movimiento, dias, observacion)
                VALUES (?, CURRENT_DATE, ?, ?, ?)
            """, (id_contrato, tipo, dias, obs))
            conn.commit()
            return True, "Ajuste registrado."
        except Exception as e:
            return False, str(e)
        finally:
            conn.close()
```

## Archivo: views/modules/reports_view.py
```python
# 


import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from tkinter import filedialog, messagebox
from datetime import datetime
import threading

# Importamos el servicio
from logics.perc_export_service import PercExportService

class ReportsView(ttk.Frame):
    def __init__(self, parent, controller):
        super().__init__(parent)
        self.controller = controller
        self.service = PercExportService() # Instancia única del servicio
        self.pack(fill=BOTH, expand=True, padx=20, pady=20)

        # Título principal
        lbl_title = ttk.Label(self, text="Generación de Reportes", font=("Helvetica", 16, "bold"))
        lbl_title.pack(pady=(0, 20), anchor="w")

        # Contenedor con scroll (por si hay muchos reportes)
        self.main_container = ttk.Frame(self)
        self.main_container.pack(fill=BOTH, expand=True)



#--------------------------------------------------SECCIÓN DE REPORTES-------------------------------------------
        # --- DEFINICIÓN DE REPORTES ---
        # Solo tienes que agregar elementos a esta lista para crear nuevos botones
        self._create_report_section(
            title="Plantilla PERC - Empleados",
            filename_prefix="EMPLEADOS_PERC",
            export_method=self.service.generate_empleados_perc_excel
        )


        self._create_report_with_input_section(
            title="Plantilla PERC - Programación de Horas",
            filename_prefix="PROGRAMACION_HORAS_PERC",
            export_method=self.service.generate_programacion_horas_perc_excel
        )
        self._create_report_section_attemporal(
            title="Descargar Base de Datos en Excel",
            filename_prefix="Base de datos Talento Humano",
            export_method=self.service.generate_horas_extras_excel # Aún en contrucción solo generé el maquetado
        )


#----------------------------------------------FIN-SECCIÓN DE REPORTES-------------------------------------------
    def _create_report_section_attemporal(self, title, filename_prefix, export_method):
        """
        Caja de reporte sin un periodo en especifico.
        Pensado para reportes de descarga de tablas de la base de datos.
        """
        card = ttk.Labelframe(self.main_container, text=title, padding=15)
        card.pack(fill=X, pady=10, anchor="n")

        row = ttk.Frame(card)
        row.pack(fill=X)
        # --- Barra de progreso (oculta) ---
        progress = ttk.Progressbar(card, mode='indeterminate', bootstyle="success-striped")

        # --- Botón de Generar ---
        # Usamos una función lambda para pasar los widgets específicos de esta card
        btn_generar = ttk.Button(
            row, 
            text="Generar Excel", 
            bootstyle="success",
            command=lambda: self._handle_generate_click_no_period(
              btn_generar, progress, filename_prefix, export_method
            )
        )
        btn_generar.pack(side=LEFT)


    def _create_report_section(self, title, filename_prefix, export_method):
        """Crea una fila de controles para un reporte específico"""
        card = ttk.Labelframe(self.main_container, text=title, padding=15)
        card.pack(fill=X, pady=10, anchor="n")

        row = ttk.Frame(card)
        row.pack(fill=X)


        # --- Selector de Mes ---
        ttk.Label(row, text="Mes:").pack(side=LEFT, padx=(0, 5))
        combo_mes = ttk.Combobox(row, values=[
            "01 - Enero", "02 - Febrero", "03 - Marzo", "04 - Abril",
            "05 - Mayo", "06 - Junio", "07 - Julio", "08 - Agosto",
            "09 - Septiembre", "10 - Octubre", "11 - Noviembre", "12 - Diciembre"
        ], state="readonly", width=15)
        combo_mes.current(datetime.now().month - 1)
        combo_mes.pack(side=LEFT, padx=(0, 15))

        # --- Selector de Año ---
        ttk.Label(row, text="Año:").pack(side=LEFT, padx=(0, 5))
        spin_anio = ttk.Spinbox(row, from_=2020, to=2030, width=8)
        spin_anio.set(datetime.now().year)
        spin_anio.pack(side=LEFT, padx=(0, 15))

        # --- Barra de progreso (oculta) ---
        progress = ttk.Progressbar(card, mode='indeterminate', bootstyle="success-striped")

        # --- Botón de Generar ---
        # Usamos una función lambda para pasar los widgets específicos de esta card
        btn_generar = ttk.Button(
            row, 
            text="Generar Excel", 
            bootstyle="success",
            command=lambda: self._handle_generate_click(
                combo_mes, spin_anio, btn_generar, progress, filename_prefix, export_method
            )
        )
        btn_generar.pack(side=LEFT)

    def _handle_generate_click_no_period(self, btn, progress, prefix, method):
        """Lógica genérica para el botón de generar"""

        filename = f"{prefix}_.xlsx"
        filepath = filedialog.asksaveasfilename(
            defaultextension=".xlsx",
            filetypes=[("Excel Files", "*.xlsx")],
            initialfile=filename,
            title="Guardar Reporte"
        )

        if not filepath:
            return

        # Bloquear UI de esta card específica
        self._set_loading_state(True,  btn, progress)

        # Ejecutar en hilo separado
        thread = threading.Thread(
            target=self._run_export_logic, 
            args=(method, filepath,  btn, progress)
        )
        thread.start()

    def _handle_generate_click(self, combo_mes, spin_anio, btn, progress, prefix, method):
        """Lógica genérica para el botón de generar"""
        mes_txt = combo_mes.get()
        mes_num = mes_txt.split(" - ")[0]
        anio = spin_anio.get()

        filename = f"{prefix}_{anio}_{mes_num}.xlsx"
        filepath = filedialog.asksaveasfilename(
            defaultextension=".xlsx",
            filetypes=[("Excel Files", "*.xlsx")],
            initialfile=filename,
            title="Guardar Reporte"
        )

        if not filepath:
            return

        # Bloquear UI de esta card específica
        self._set_loading_state(True, combo_mes, spin_anio, btn, progress)

        # Ejecutar en hilo separado
        thread = threading.Thread(
            target=self._run_export_logic, 
            args=(method, anio, mes_num, filepath, combo_mes, spin_anio, btn, progress)
        )
        thread.start()

    def _run_export_logic(self, method, year, month, filepath, *widgets):
        """Ejecuta la función del servicio recibida por parámetro"""
        try:
            # Llamamos al método que se pasó por argumento
            success, message = method(year, month, filepath)
        except Exception as e:
            success, message = False, f"Error inesperado: {str(e)}"
        
        # Volver al hilo principal para actualizar UI
        self.after(0, lambda: self._on_export_finished(success, message, *widgets))

    def _on_export_finished(self, success, message, combo_mes, spin_anio, btn, progress):
        self._set_loading_state(False, combo_mes, spin_anio, btn, progress)
        if success:
            messagebox.showinfo("Éxito", message)
        else:
            messagebox.showerror("Error", message)

    def _set_loading_state(self, is_loading, combo, spin, btn, progress):
        """Habilita o deshabilita los widgets de una card específica"""
        if is_loading:
            btn.config(state="disabled", text="Generando...")
            combo.config(state="disabled")
            spin.config(state="disabled")
            progress.pack(fill=X, pady=(10, 0))
            progress.start(10)
        else:
            progress.stop()
            progress.pack_forget()
            btn.config(state="normal", text="Generar Excel")
            combo.config(state="readonly")
            spin.config(state="normal")
    def _create_report_with_input_section(self, title, filename_prefix, export_method):
        """Crea una card que requiere cargar un archivo antes de generar"""
        card = ttk.Labelframe(self.main_container, text=title, padding=15)
        card.pack(fill=X, pady=10)

        # Fila 1: Selección de archivo
        row1 = ttk.Frame(card)
        row1.pack(fill=X, pady=(0, 10))
        
        lbl_file = ttk.Label(row1, text="Plantilla PERC Descargada (Programación Horas):", font=("Helvetica", 9, "italic"))
        lbl_file.pack(side=LEFT, padx=(0, 10))
        
        path_var = ttk.StringVar(value="No se ha seleccionado archivo...")
        entry_path = ttk.Entry(row1, textvariable=path_var, state="readonly", width=50)
        entry_path.pack(side=LEFT, padx=(0, 5))

        def select_input_file():
            path = filedialog.askopenfilename(filetypes=[("Excel Files", "*.xlsx *.xls")])
            if path:
                path_var.set(path)

        btn_browse = ttk.Button(row1, text="Buscar...", command=select_input_file, bootstyle="secondary-outline")
        btn_browse.pack(side=LEFT)

        # Fila 2: Periodo y Generar
        row2 = ttk.Frame(card)
        row2.pack(fill=X)

        ttk.Label(row2, text="Mes:").pack(side=LEFT, padx=(0, 5))
        #combo_mes = ttk.Combobox(row2, values=[f"{i:02d}" for i in range(1, 13)], width=5, state="readonly")
        combo_mes = ttk.Combobox(row2, values=[
            "01 - Enero", "02 - Febrero", "03 - Marzo", "04 - Abril",
            "05 - Mayo", "06 - Junio", "07 - Julio", "08 - Agosto",
            "09 - Septiembre", "10 - Octubre", "11 - Noviembre", "12 - Diciembre"
        ], state="readonly", width=15)
        combo_mes.current(datetime.now().month - 1)
        combo_mes.pack(side=LEFT, padx=(0, 10))

        ttk.Label(row2, text="Año:").pack(side=LEFT, padx=(0, 5))
        spin_anio = ttk.Spinbox(row2, from_=2020, to=2030, width=8)
        spin_anio.set(datetime.now().year)
        spin_anio.pack(side=LEFT, padx=(0, 15))

        progress = ttk.Progressbar(card, mode='indeterminate', bootstyle="success-striped")

        btn_generar = ttk.Button(
            row2, 
            text="Procesar y Guardar", 
            bootstyle="success",
            command=lambda: self._handle_generate_with_input(
                path_var.get(), combo_mes, spin_anio, btn_generar, progress, filename_prefix, export_method
            )
        )
        btn_generar.pack(side=LEFT)

    def _handle_generate_with_input(self, input_path, combo_mes, spin_anio, btn, progress, prefix, method):
        # Validar que seleccionó archivo
        if "No se ha seleccionado" in input_path or not input_path:
            messagebox.showwarning("Atención", "Por favor seleccione el archivo Excel de origen primero.")
            return

        mes_txt = combo_mes.get()
        mes_num = mes_txt.split(" - ")[0]
        anio = spin_anio.get()
        
        # Pedir donde GUARDAR
        filename = f"{prefix}_{anio}_{mes_num}.xlsx"
        output_path = filedialog.asksaveasfilename(
            defaultextension=".xlsx",
            filetypes=[("Excel Files", "*.xlsx")],
            initialfile=filename,
            title="Guardar Resultado"
        )

        if not output_path: return

        # Bloquear UI
        self._set_loading_state(True, combo_mes, spin_anio, btn, progress)

        # Hilo
        thread = threading.Thread(
            target=self._run_export_logic_with_input, 
            args=(method, anio, mes_num, output_path, input_path, combo_mes, spin_anio, btn, progress)
        )
        thread.start()

    def _run_export_logic_with_input(self, method, year, month, output_path, input_path, *widgets):
        """Ejecuta la lógica pasando el input_path adicional"""
        try:
            # Aquí pasamos tanto el output_path como el input_path
            success, message = method(year, month, output_path, input_path)
        except Exception as e:
            success, message = False, f"Error: {str(e)}"
        
        self.after(0, lambda: self._on_export_finished(success, message, *widgets))
```
[MISSING FILE: views/modules/attendace_view.py]

## Archivo: views/modules/configuration_view.py
```python
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from ttkbootstrap.dialogs import Messagebox
from models.catalogs_dao import CatalogsDAO

class ConfigurationView(ttk.Frame):
    def __init__(self, parent):
        super().__init__(parent)
        self.pack(fill=BOTH, expand=True)
        
        ttk.Label(self, text="Configuración de Catálogos del Sistema", font=("Segoe UI", 18, "bold")).pack(pady=10)
        
        self.notebook = ttk.Notebook(self, bootstyle="primary")
        self.notebook.pack(fill=BOTH, expand=True, padx=10, pady=10)
        
        self.dao = CatalogsDAO()
        
        # 1. Pestañas Básicas (Texto simple)
        self._init_basic_tabs()
        
        # 2. Pestañas de Asistencia (Avanzadas)
        self._init_attendance_tabs()

    def _init_basic_tabs(self):
        # DEPARTAMENTOS
        self.notebook.add(CatalogTab(
            self.notebook, "Departamentos", ("ID", "Nombre", "Cód. Interno"),
            self.dao.get_departamentos, self.dao.crud_departamento,
            fields=[("Nombre Área:", "text"), ("Cód. Reporte:", "text")]
        ), text="Departamentos")


        # PUESTOS (ACTUALIZADO CON DEPARTAMENTO)
        jefes_source = self.dao.get_puestos_jefatura_combo()
        perc_source = self.dao.get_grupos_perc_combo()
        # Reutilizamos el método existente para obtener departamentos
        # Nota: get_departamentos retorna (id, nombre, cod), transformamos a (id, nombre)
        raw_deptos = self.dao.get_departamentos()
        deptos_source = [(d[0], d[1]) for d in raw_deptos]

        self.notebook.add(CatalogTab(
            self.notebook, "Cargos / Puestos", 
            # Columnas Visuales de la Tabla:
            ("ID", "Nombre Cargo", "Departamento", "¿Tiene Personal?", "Jefe Inmediato", "Categoría PERC"),
            self.dao.get_puestos, 
            self.dao.crud_puesto,
            fields=[
                # Orden Visual de Inputs:
                ("Nombre del Cargo:", "text"),
                ("Departamento:", "combo", deptos_source), # <-- NUEVO CAMPO
                ("¿Tiene Personal a Cargo?:", "checkbox"),
                ("Jefe Inmediato:", "combo", jefes_source),
                ("Grupo PERC:", "combo", perc_source)
            ]
        ), text="Puestos")

        # UNIDADES
        self.notebook.add(CatalogTab(
            self.notebook, "Unidades Producción", ("ID", "Nombre Unidad", "Cód. Contable"),
            self.dao.get_unidades_produccion, self.dao.crud_unidad,
            fields=[("Nombre Descriptivo:", "text"), ("Cód. Contable:", "text")]
        ), text="Unidades Producción")

            # --- TIPOS DE CONTRATO ---
        self.notebook.add(CatalogTab(
            self.notebook, 
            title="Modalidades de Contratación", 
            columns=("ID", "Modalidad Legal"),
            dao_fetch=self.dao.get_tipos_contrato, 
            dao_crud=self.dao.crud_tipo_contrato,
            fields=[("Nombre Modalidad:", "text")]
        ), text="Tipos de Contrato")

        # JORNADAS LABORALES
        self.notebook.add(CatalogTab(
            self.notebook, "Jornadas Laborales", ("ID", "Descripción", "Horas Diarias"),
            self.dao.get_jornadas, self.dao.crud_jornada,
            fields=[("Nombre (ej: Turno A):", "text"), ("Horas (ej: 8.0):", "text")]
        ), text="Jornadas")

    def _init_attendance_tabs(self):
        # A. CATEGORÍAS MACRO
        self.notebook.add(CatalogTab(
            self.notebook, "Categorías Inasistencia", ("ID", "Categoría Macro"),
            self.dao.get_categorias_inasistencia, self.dao.crud_categoria_inasistencia,
            fields=[("Nombre Categoría:", "text")]
        ), text="Inasistencias (Categorías)")

        # B. TIPOS ESPECÍFICOS
        # Obtenemos la lista de categorías para llenar el Combo: [(id, nombre), ...]
        cats_raw = self.dao.get_categorias_inasistencia()
        # ORDINARIA = Descuenta | NINGUNA = No Descuenta
        opciones_descuento = [("NINGUNA", "NO Descuenta Saldo"), ("ORDINARIA", "SÍ Descuenta Saldo (Ord)")]
        
        self.notebook.add(CatalogTab(
            self.notebook, "Tipos de Inasistencia", 
            ("ID", "Descripción", "Categoría", "¿Descuenta?", "¿Goce Sueldo?"),
            self.dao.get_tipos_inasistencia, self.dao.crud_tipo_inasistencia,
            fields=[
                ("Descripción:", "text"),
                ("Categoría:", "combo", cats_raw),
                ("Afecta Vacaciones:", "combo", opciones_descuento), # Usamos lista simple
                ("Con Goce de Sueldo:", "checkbox")
            ]
        ), text="Inasistencias (Tipos)")
        
        # C. REGLAS DE VACACIONES (Matriz)
        vacation_types = self.dao.get_only_vacation_types_combo()
        
        self.notebook.add(CatalogTab(
            self.notebook, "Reglas de Antigüedad", 
            ("ID", "Tipo Vacación", "Año Antigüedad", "Días a Otorgar", "ID Tipo Raw"),
            self.dao.get_reglas_vacaciones, self.dao.crud_regla_vacacion,
            fields=[
                ("Tipo de Vacación:", "combo", vacation_types),
                ("Año de Antigüedad (1, 2...):", "text"),
                ("Días a Otorgar:", "text")
            ]
        ), text="Reglas Vacaciones")


class CatalogTab(ttk.Frame):
    """
    Componente CRUD Genérico v2.0
    Soporta: Entry, Combobox (con mapeo ID) y Checkbox.
    """
    def __init__(self, parent, title, columns, dao_fetch, dao_crud, fields):
        super().__init__(parent, padding=10)
        self.title = title
        self.columns = columns
        self.dao_fetch = dao_fetch
        self.dao_crud = dao_crud
        self.fields_config = fields 
        
        self.selected_id = None
        self.widgets = [] # Lista de diccionarios {'type': 'text/combo', 'widget': w, 'data': ...}
        
        self._setup_ui()
        self.refresh_table()


    def _setup_ui(self):
            # --- Formulario Dinámico ---
            # Usamos bootstyle info para destacar el área de edición
            form_frame = ttk.Labelframe(self, text=f"Gestión de {self.title}", padding=15, bootstyle="info")
            form_frame.pack(fill=X, pady=5, padx=5)
            
            # CONTENEDOR DE INPUTS (Arriba)
            inputs_container = ttk.Frame(form_frame)
            inputs_container.pack(fill=X, expand=True)
            
            # Lógica de Grid Responsivo (2 columnas si hay muchos campos, o flujo natural)
            # Para mantenerlo simple y genérico, usaremos pack con side=LEFT y wrap visual si fuera necesario.
            # Pero dado que pediste "botones abajo", asumiremos un flujo vertical u horizontal limpio.
            
            current_row = ttk.Frame(inputs_container)
            current_row.pack(fill=X, pady=5)

            for field_conf in self.fields_config:
                lbl_text = field_conf[0]
                w_type = field_conf[1]
                
                # Contenedor individual campo
                f_item = ttk.Frame(current_row)
                f_item.pack(side=LEFT, padx=10, anchor=N)
                
                if w_type == "text":
                    ttk.Label(f_item, text=lbl_text, font=("Segoe UI", 9)).pack(anchor=W)
                    w = ttk.Entry(f_item, width=25)
                    w.pack(pady=2)
                    self.widgets.append({'type': 'text', 'widget': w})
                    
                elif w_type == "combo":
                    ttk.Label(f_item, text=lbl_text, font=("Segoe UI", 9)).pack(anchor=W)
                    source_data = field_conf[2] 
                    # Ordenamos alfabéticamente para facilitar búsqueda visual
                    sorted_source = sorted(source_data, key=lambda x: x[1]) if source_data else []
                    values = [x[1] for x in sorted_source]
                    
                    w = ttk.Combobox(f_item, values=values, state="readonly", width=25)
                    w.pack(pady=2)
                    self.widgets.append({'type': 'combo', 'widget': w, 'source': sorted_source}) # Usamos la lista ordenada

                elif w_type == "checkbox":
                    ttk.Label(f_item, text="").pack() # Spacer
                    var = ttk.IntVar(value=0)
                    w = ttk.Checkbutton(f_item, text=lbl_text, variable=var, bootstyle="round-toggle")
                    w.pack(pady=5)
                    self.widgets.append({'type': 'check', 'widget': w, 'var': var})

            # CONTENEDOR DE BOTONES (Abajo, centrado o expandido)
            btn_frame = ttk.Frame(form_frame)
            btn_frame.pack(fill=X, pady=(15, 0)) # Margen superior para separar de inputs
            
            # Centramos los botones usando un frame interno
            center_btns = ttk.Frame(btn_frame)
            center_btns.pack(anchor=CENTER)

            self.btn_save = ttk.Button(center_btns, text="💾 Guardar", command=self.save, bootstyle="success", width=15)
            self.btn_save.pack(side=LEFT, padx=5)
            
            self.btn_cancel = ttk.Button(center_btns, text="🧹 Limpiar", command=self.clear_form, bootstyle="secondary", width=15)
            self.btn_cancel.pack(side=LEFT, padx=5)
            
            self.btn_delete = ttk.Button(center_btns, text="🗑 Eliminar", command=self.delete, bootstyle="danger", width=15)
            self.btn_delete.pack(side=LEFT, padx=5)

            # --- Tabla ---
            self.tree = ttk.Treeview(self, columns=[str(i) for i in range(len(self.columns))], show="headings", bootstyle="info")
            
            for i, col_name in enumerate(self.columns):
                self.tree.heading(str(i), text=col_name)
                # Ajuste automático de ancho básico
                width = 200 if "Nombre" in col_name else 100
                self.tree.column(str(i), width=width)
                    
            self.tree.pack(fill=BOTH, expand=True, pady=10, padx=5)
            
            # Scrollbar
            sb = ttk.Scrollbar(self.tree, orient=VERTICAL, command=self.tree.yview)
            self.tree.configure(yscroll=sb.set)
            sb.pack(side=RIGHT, fill=Y)

            self.tree.bind("<Double-1>", self.on_double_click)

    def refresh_table(self):
        for item in self.tree.get_children(): self.tree.delete(item)
        rows = self.dao_fetch()
        for row in rows:
            # Cortamos la fila visualmente según las columnas definidas
            # (El DAO de tipos devuelve datos extra al final que no mostramos en tabla pero usamos al editar)
            visual_row = row[:len(self.columns)]
            self.tree.insert("", END, values=visual_row, tags=(row,)) # Guardamos toda la data en tags
            
    def on_double_click(self, event):
            sel = self.tree.selection()
            if not sel: return
            
            item = self.tree.item(sel[0])
            row_id = item['values'][0]

            # 1. Recuperar Data Real de BD
            full_rows = self.dao_fetch()
            actual_data = next((r for r in full_rows if r[0] == row_id), None)
            
            if not actual_data: return

            self.selected_id = row_id
            self.btn_save.config(text="Actualizar", bootstyle="warning")

            # --- ESTRATEGIA DE CURSORES ---
            # visual_idx: Para campos de texto (saltamos el ID en pos 0)
            visual_idx = 1 
            
            # raw_idx: Para Combos y Checks. 
            # Empieza justo donde terminan las columnas visibles de la tabla.
            raw_idx = len(self.columns) 

            for w_conf in self.widgets:
                
                # CASO 1: Campo de Texto (Generalmente mapea a columnas visuales)
                if w_conf['type'] == 'text':
                    val = actual_data[visual_idx]
                    w_conf['widget'].delete(0, END)
                    # Convertimos a string por si acaso es número, y manejamos None
                    w_conf['widget'].insert(0, str(val) if val is not None else "")
                    
                    visual_idx += 1 # Avanzamos al siguiente dato visual

                # CASO 2: Combos y Checks (Buscan IDs o Booleanos en la zona RAW u Oculta)
                elif w_conf['type'] in ['combo', 'check']:
                    
                    # Determinamos de dónde sacar el dato
                    if len(actual_data) > len(self.columns):
                        # Si hay datos ocultos (RAW), tomamos de ahí secuencialmente
                        val_raw = actual_data[raw_idx]
                        raw_idx += 1
                    else:
                        # Fallback para tablas simples sin datos ocultos
                        val_raw = actual_data[visual_idx]
                        visual_idx += 1

                    # APLICAR VALOR AL WIDGET
                    if w_conf['type'] == 'combo':
                        if val_raw is None:
                            w_conf['widget'].set('')
                        else:
                            # Buscar el texto que corresponde a ese ID en la lista fuente
                            # Comparamos como strings por seguridad si los IDs vienen mezclados
                            txt = next((x[1] for x in w_conf['source'] if str(x[0]) == str(val_raw)), "")
                            w_conf['widget'].set(txt)
                    
                    elif w_conf['type'] == 'check':
                        # Asegurar 1 o 0
                        is_checked = 1 if val_raw and int(val_raw) == 1 else 0
                        w_conf['var'].set(is_checked)

    def clear_form(self):
        self.selected_id = None
        for w in self.widgets:
            if w['type'] == 'text': w['widget'].delete(0, END)
            elif w['type'] == 'combo': w['widget'].set('')
            elif w['type'] == 'check': w['var'].set(1)
        self.btn_save.config(text="Guardar", bootstyle="success")
        self.tree.selection_remove(self.tree.selection())

    def save(self):
            params = []
            for w in self.widgets:
                if w['type'] == 'text':
                    val = w['widget'].get().strip()
                    # Validación básica para textos: obligatorios
                    if not val: 
                        Messagebox.show_error("Los campos de texto son obligatorios", "Error")
                        return
                    params.append(val)
                    
                elif w['type'] == 'combo':
                    txt = w['widget'].get()
                    
                    # --- CAMBIO CRÍTICO: Permitir Combos Vacíos ---
                    if not txt:
                        # Si no seleccionó nada, enviamos None (NULL en BD)
                        params.append(None)
                    else:
                        # Si seleccionó algo, buscamos su ID
                        # Usamos next con default None por seguridad
                        id_val = next((x[0] for x in w['source'] if x[1] == txt), None)
                        
                        if id_val is None:
                            # Caso raro: Texto en combo que no coincide con la lista (Usuario escribió a mano)
                            Messagebox.show_error(f"El valor '{txt}' no es válido en la lista.", "Error")
                            return
                        params.append(id_val)
                        
                elif w['type'] == 'check':
                    params.append(w['var'].get())

            # Ejecución del CRUD
            if self.selected_id:
                ok, msg = self.dao_crud("UPDATE", self.selected_id, *params)
            else:
                ok, msg = self.dao_crud("INSERT", None, *params)
                
            if ok:
                Messagebox.show_info(msg, "Éxito")
                self.clear_form()
                self.refresh_table()
                
                # --- TRUCO PRO: Refrescar la fuente de datos si es necesario ---
                # Si acabamos de guardar un Puesto que es Jefe, deberíamos recargar 
                # los combos para que aparezca disponible de inmediato.
                # Por simplicidad en este framework genérico, la solución rápida es:
                # El usuario deberá reiniciar la app o cambiar de pestaña para ver 
                # al nuevo jefe en la lista, O implementamos un reload (más complejo).
            else:
                Messagebox.show_error(msg, "Error")

    def delete(self):
        if not self.selected_id: return
        if Messagebox.yesno("¿Eliminar?", "Confirmar") == 'Yes':
            ok, msg = self.dao_crud("DELETE", self.selected_id)
            if ok: 
                self.clear_form()
                self.refresh_table()
            else:
                Messagebox.show_error(msg, "Error")
```
[MISSING FILE: views/modules/contract_view.py]
[MISSING FILE: views/modules/employee_view.py]

## Archivo: views/modules/vacation_balance_view.py
```python
import ttkbootstrap as ttk
from ttkbootstrap.constants import *
from ttkbootstrap.dialogs import Messagebox
from views.components.employee_selector import EmployeeSelector
from models.attendance_dao import AttendanceDAO 
from models.kardex_dao import KardexDAO
from logics.vacation_service import VacationService
from logics.report_service import ReportService

class VacationBalanceView(ttk.Frame):
    def __init__(self, parent):
        super().__init__(parent)
        self.pack(fill=BOTH, expand=True)

        self.report_service = ReportService()         
        self.att_dao = AttendanceDAO()
        self.kardex_dao = KardexDAO()
        
        self.current_emp_id = None
        self.contracts_map = []
        
        self._setup_ui()

    def _setup_ui(self):
        # Header
        header = ttk.Frame(self, padding=10)
        header.pack(fill=X)
        ttk.Label(header, text="Kardex de Vacaciones", font=("Segoe UI", 18, "bold"), justify='center').pack(side=LEFT)
        
        # --- FILTROS ---
        filter_frame = ttk.Labelframe(self, text="Filtros de Consulta", padding=10, bootstyle="info")
        filter_frame.pack(fill=X, padx=10, pady=5)
        
        # === FILA 1: DATOS DEL EMPLEADO Y CONTRATO ===
        row1 = ttk.Frame(filter_frame)
        row1.pack(fill=X, pady=(0, 5)) # Un poco de espacio abajo para separar de la fila 2

        # 1. Selector Empleado
        f_emp = ttk.Frame(row1)
        f_emp.pack(side=LEFT, padx=5)
        ttk.Button(f_emp, text="🔍 Empleado", command=self.open_search, bootstyle="info-outline").pack(side=LEFT)
        self.lbl_emp = ttk.Label(f_emp, text="Seleccione un colaborador...", font=("Segoe UI", 10, "bold"))
        self.lbl_emp.pack(side=LEFT, padx=10)

        # 2. Selector Contrato
        f_con = ttk.Frame(row1)
        f_con.pack(side=LEFT, padx=15, fill=X, expand=True)
        ttk.Label(f_con, text="Contrato:").pack(side=LEFT)
        self.cb_contrato = ttk.Combobox(f_con, state="readonly")
        self.cb_contrato.pack(side=LEFT, padx=5, fill=X, expand=True) # Que ocupe el espacio restante
        self.cb_contrato.bind("<<ComboboxSelected>>", self.run_report)

        # === FILA 2: FECHAS Y BOTÓN DE ACCIÓN ===
        row2 = ttk.Frame(filter_frame)
        row2.pack(fill=X, pady=5)

        # 3. Fechas (Lado Izquierdo)
        f_date = ttk.Frame(row2)
        f_date.pack(side=LEFT, padx=5)
        
        ttk.Label(f_date, text="Desde:").pack(side=LEFT)
        self.date_ini = ttk.DateEntry(f_date, dateformat='%Y-%m-%d', width=12)
        self.date_ini.pack(side=LEFT, padx=5)
        self.date_ini.entry.delete(0, END) 

        ttk.Label(f_date, text="Hasta:").pack(side=LEFT, padx=(15, 0)) # Margen extra a la izquierda
        self.date_fin = ttk.DateEntry(f_date, dateformat='%Y-%m-%d', width=12)
        self.date_fin.pack(side=LEFT, padx=5)
        self.date_fin.entry.delete(0, END)

        # 4. Botón Filtrar (Lado Derecho - Destacado)
        ttk.Button(row2, text="Filtrar Reporte", command=self.run_report, bootstyle="secondary").pack(side=RIGHT, padx=10)


        # --- TABLA DE RESULTADOS ---
        result_frame = ttk.Frame(self, padding=10)
        result_frame.pack(fill=BOTH, expand=True)

        cols = ("fecha", "tipo", "detalle", "debe", "haber", "saldo")
        self.tree = ttk.Treeview(result_frame, columns=cols, show="headings")
        
        # Encabezados
        self.tree.heading("fecha", text="Fecha")
        self.tree.column("fecha", width=70, stretch=False)
        
        self.tree.heading("tipo", text="Movimiento")
        self.tree.column("tipo", width=200, stretch=False)
        
        self.tree.heading("detalle", text="Detalle / Observación")
        self.tree.column("detalle", width=300, anchor=W)
        
        self.tree.heading("debe", text="Devengado") 
        self.tree.column("debe", width=70, anchor=E)
        
        self.tree.heading("haber", text="Ganado") 
        self.tree.column("haber", width=70, anchor=E)
        
        self.tree.heading("saldo", text="Saldo")
        self.tree.column("saldo", width=70, anchor=E)

        self.tree.pack(fill=BOTH, expand=True, side=LEFT)
        
        sb = ttk.Scrollbar(result_frame, orient=VERTICAL, command=self.tree.yview)
        self.tree.configure(yscroll=sb.set)
        sb.pack(side=RIGHT, fill=Y)

        # Footer
        footer = ttk.Frame(self, padding=5)
        footer.pack(fill=X)
        ttk.Label(footer, text="* Devengado (Debe) = Días tomados | Ganado (Haber) = Días acumulados", bootstyle="secondary").pack(side=LEFT)

    # --- LÓGICA ---
    def open_search(self):
        EmployeeSelector(self, self.on_employee_selected)

    def on_employee_selected(self, emp_id, emp_code, emp_name):
        self.current_emp_id = emp_id
        self.lbl_emp.config(text=f"{emp_name}", bootstyle="primary")
        
        self.contracts_map = self.att_dao.get_active_contracts_by_employee(emp_id)
        vals = [c[1] for c in self.contracts_map]
        self.cb_contrato['values'] = vals
        
        if vals:
            self.cb_contrato.current(0)
            self.run_report()
        else:
            self.cb_contrato.set('')
            self.clear_table()

    def run_report(self, event=None):
        txt_contrato = self.cb_contrato.get()
        if not txt_contrato: return

        id_con = None
        for cid, cname in self.contracts_map:
            if cname == txt_contrato:
                id_con = cid
                break
        if id_con is None: return

        f_ini = self.date_ini.entry.get()
        if not f_ini: f_ini = None
        f_fin = self.date_fin.entry.get()
        if not f_fin: f_fin = None

        self.clear_table()



        self.clear_table()
        self.master.config(cursor="watch")
        self.master.update()

        try:
            # === LLAMADA AL SERVICIO (Una sola línea limpia) ===
            data = self.report_service.get_kardex_report_data(id_con, f_ini, f_fin)
            
            # === RENDERIZADO ===
            
            # A. Saldo Anterior
            if data["saldo_anterior"] != 0 or f_ini:
                 self.tree.insert("", END, values=(
                    f_ini if f_ini else "---",
                    "SALDO ANTERIOR",
                    "Arrastre de periodo previo",
                    "", "", 
                    f"{data['saldo_anterior']:.2f}"
                ), tags=('bold',))
            
            # B. Filas
            for row in data["movimientos"]:
                tag = 'projection' if row['es_proyeccion'] else ''
                
                debe_str = f"{row['debe']:.2f}" if row['debe'] > 0 else ""
                haber_str = f"{row['haber']:.2f}" if row['haber'] > 0 else ""
                
                self.tree.insert("", END, values=(
                    row['fecha'],
                    row['tipo'],
                    row['detalle'],
                    debe_str,
                    haber_str,
                    f"{row['saldo']:.2f}"
                ), tags=(tag,))

            # C. Separador Proyecciones (Opcional, si detectamos cambio de tipo)
            # (Simplificado aquí, pero podrías insertar una fila vacía antes de la primera proyección)

            # D. Totales
            tot = data["totales"]
            self.tree.insert("", END, values=(
                "", "TOTALES", "", 
                f"{tot['debe']:.2f}", f"{tot['haber']:.2f}", f"{tot['saldo_final']:.2f}"
            ), tags=('total',))

        except Exception as e:
            print(f"Error UI: {e}")
            Messagebox.show_error(f"Error generando reporte: {e}")
        finally:
            self.master.config(cursor="")
    def clear_table(self):
        for i in self.tree.get_children(): self.tree.delete(i)
```

## Archivo: logics/perc_export_service.py
```python
import pandas as pd
from config.db_connection import DatabaseConnection
import calendar
import sqlite3

class PercExportService:
    def __init__(self):
        self.db = DatabaseConnection()

    def generate_empleados_perc_excel(self, year, month, filepath):
        """
        Genera el reporte Excel para PERC.
        Retorna: (Success: bool, Message: str)
        """
        conn = self.db.get_connection()
        if not conn:
            return False, "No hay conexión a base de datos."

        try:
            # 1. Definir rango de fechas del periodo seleccionado
            # Primer día del mes
            start_date_str = f"{year}-{int(month):02d}-01"
            
            # Último día del mes
            last_day = calendar.monthrange(int(year), int(month))[1]
            end_date_str = f"{year}-{int(month):02d}-{last_day}"

            # 2. Query SQL
            # Nota la lógica de fechas:
            # El contrato debe haber empezado antes o durante el fin de mes
            # Y (no tener fecha fin O tener fecha fin después del inicio de mes)
            query = """
            SELECT 
                c.dni_perc as 'Identificación',
                p.nombre_puesto as 'Nombre',    -- REQUERIMIENTO: Nombre = Puesto
                c.salario as 'Salario Base',
                COALESCE(gp.codigo, 'GEN') as 'Categoría de Empleado', -- Mapeo a Grupo PERC
                '00' as 'Niveles Laborales',
                0 as 'Bonificaciones',
                0 as 'Beneficios Laborales',
                '1' as 'Tipo de Contrato'
            FROM contratos c
            JOIN empleados e ON c.id_empleado = e.id_empleado
            JOIN cat_puestos p ON c.id_puesto = p.id_puesto
            LEFT JOIN cat_grupos_perc gp ON p.id_grupo_perc = gp.id_grupo
            WHERE 
                c.activo = 1
                AND c.fecha_inicio <= ?
                AND (c.fecha_fin IS NULL OR c.fecha_fin >= ?)
            """
            
            # Usamos pandas para leer SQL directamente
            df = pd.read_sql_query(query, conn, params=(end_date_str, start_date_str))
            
            if df.empty:
                return False, "No se encontraron contratos activos en el periodo seleccionado."

            # 3. Post-Procesamiento (Opcional)
            # Asegurar que 'Identificación' sea string para conservar ceros a la izquierda si los hubiera
            df['Identificación'] = df['Identificación'].astype(str)
            df['Categoría de Empleado'] = df['Categoría de Empleado'].astype(str)


            # 4. Exportar a Excel
            # Usamos context manager para guardar
            with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
                df.to_excel(writer, index=False, sheet_name='Empleado')
                
                # Auto-ajustar ancho de columnas (Opcional, estética)
                worksheet = writer.sheets['Empleado']
                for column_cells in worksheet.columns:
                    length = max(len(str(cell.value)) for cell in column_cells)
                    worksheet.column_dimensions[column_cells[0].column_letter].width = length + 2

            return True, f"Reporte generado exitosamente en:\n{filepath}"

        except Exception as e:
            return False, f"Error generando reporte: {str(e)}"
        finally:
            conn.close()
    

    def generate_programacion_horas_perc_excel(self, year, month, filepath, input_path, dias_feriado=0, cant_horas_diarias=8):
            """
            year, month: Periodo
            filepath: Ruta donde se GUARDARÁ el resultado
            input_path: Ruta del Excel que el usuario CARGÓ
            """
            try:
                # 1. Importar el archivo cargado por el usuario
                df = pd.read_excel(input_path)

                # Limpieza de DNI (como tenías en tu lógica)
                if 'Empleado' not in df.columns:
                    return False, "El archivo cargado no tiene la columna 'Empleado'"
                
                df['dni_perc'] = df['Empleado'].str.split('__').str[1]

                # --- Función interna de cálculo ---
                def obtener_horas_programadas(anio, mes, feriados, horas_dia):
                    num_dias = calendar.monthrange(int(anio), int(mes))[1]
                    dias_laborales = 0
                    for dia in range(1, num_dias + 1):
                        if calendar.weekday(int(anio), int(mes), dia) < 5: # Lunes a Viernes
                            dias_laborales += 1
                    return (dias_laborales - int(feriados)) * int(horas_dia)

                horas_totales = obtener_horas_programadas(year, month, dias_feriado, cant_horas_diarias)
                df['horas_programadas'] = horas_totales
                
                df_base_perc = df[['Empleado','Total Empleados', 'Total Pagado', 'Componente Salarial','dni_perc','horas_programadas']].copy()

                # 2. Traer distribución desde DB
                conn = self.db.get_connection()
                query = """
                SELECT 
                    up.codigo_up || '-' || up.nombre_up AS unidad_produccion,
                    c.dni_perc,
                    COALESCE(dc.porcentaje, 0) AS porcentaje
                FROM cat_unidades_produccion AS up
                LEFT JOIN distribucion_costos AS dc ON up.id_unidad = dc.id_unidad
                LEFT JOIN contratos AS c ON dc.id_contrato = c.id_contrato;
                """
                dist_up = pd.read_sql_query(query, conn)
                conn.close()

                # 3. Procesamiento y Pivot
                base = pd.merge(df_base_perc, dist_up, on='dni_perc', how='right')
                base['horas'] = base['horas_programadas'] * (base['porcentaje'] / 100)
                base = base[['Empleado', 'Total Empleados', 'Total Pagado', 'Componente Salarial','unidad_produccion','horas']].fillna({'horas':0})
                
                df_pivot = base.pivot(
                    index=['Empleado', 'Total Empleados', 'Total Pagado', 'Componente Salarial'],
                    columns='unidad_produccion',
                    values='horas'
                ).reset_index()

                # 4. Exportar al filepath seleccionado por el usuario
                with pd.ExcelWriter(filepath, engine='openpyxl') as writer:
                    df_pivot[df_pivot['Empleado'].notna()].to_excel(writer, index=False, sheet_name='Programación Hora')
                    
                    worksheet = writer.sheets['Programación Hora']
                    for column_cells in worksheet.columns:
                        length = max(len(str(cell.value)) for cell in column_cells)
                        worksheet.column_dimensions[column_cells[0].column_letter].width = length + 2

                return True, f"Reporte procesado y guardado en:\n{filepath}"

            except Exception as e:
                return False, f"Error en procesamiento: {str(e)}"


    def generate_horas_extras_excel():
        return 0
```

## Archivo: logics/report_service.py
```python
from models.kardex_dao import KardexDAO
from logics.vacation_service import VacationService

class ReportService:
    def __init__(self):
        self.kardex_dao = KardexDAO()
        self.vac_service = VacationService()

    def get_kardex_report_data(self, id_contrato, fecha_ini=None, fecha_fin=None):
        """
        Genera la estructura de datos completa para el reporte de Kardex.
        Agnóstico de la UI (sirve para Tkinter, Excel, PDF, JSON API).
        """
        response = {
            "saldo_anterior": 0.0,
            "movimientos": [], # Lista de dicts
            "totales": {"debe": 0.0, "haber": 0.0, "saldo_final": 0.0}
        }

        # 1. Procesar devengos automáticos hasta hoy (Write to BD)
        try:
            self.vac_service.process_monthly_accruals(id_contrato)
        except Exception as e:
            print(f"Error procesando devengos automáticos: {e}")

        # 2. Obtener datos históricos (Read from BD)
        saldo_ant, raw_movs = self.kardex_dao.get_kardex_report(id_contrato, fecha_ini, fecha_fin)
        response["saldo_anterior"] = saldo_ant
        
        current_balance = saldo_ant
        total_debe = 0.0
        total_haber = 0.0

        # 3. Procesar filas históricas
        # raw_movs estructura: (id, fecha, tipo, obs, dias, f_ini_real, f_fin_real)
        for m in raw_movs:
            dias = m[4]
            current_balance += dias
            
            # Formatear detalle
            detalle = m[3]
            if m[5] and m[6]:
                detalle = f"{detalle} [Del {m[5]} al {m[6]}]"

            # Clasificar Debe/Haber
            debe = abs(dias) if dias < 0 else 0.0
            haber = dias if dias > 0 else 0.0
            
            total_debe += debe
            total_haber += haber

            response["movimientos"].append({
                "fecha": m[1],
                "tipo": m[2],
                "detalle": detalle,
                "debe": debe,
                "haber": haber,
                "saldo": current_balance,
                "es_proyeccion": False
            })

        # 4. Procesar Proyecciones (Si hay fecha fin futura)
        if fecha_fin:
            proyecciones = self.vac_service.get_future_projections(id_contrato, fecha_fin)
            for p in proyecciones:
                dias = p['dias']
                current_balance += dias
                total_haber += dias # Proyección siempre suma (es ganancia futura)
                
                response["movimientos"].append({
                    "fecha": p['fecha'],
                    "tipo": "PROYECCION",
                    "detalle": p['detalle'],
                    "debe": 0.0,
                    "haber": dias,
                    "saldo": current_balance,
                    "es_proyeccion": True
                })

        # 5. Totales Finales
        response["totales"]["debe"] = total_debe
        response["totales"]["haber"] = total_haber
        response["totales"]["saldo_final"] = current_balance
        
        return response
```

## Archivo: logics/time_calculator.py
```python
from datetime import datetime, timedelta

class TimeCalculator:
    
    @staticmethod
    def calculate_duration(fecha_ini, fecha_fin, es_por_horas=False, hora_ini="00:00", hora_fin="00:00", jornada_horas=8):
        try:
            # Caso 1: Por Días (Lógica mejorada: Excluir Sábados y Domingos )
            if not es_por_horas:
                start = datetime.strptime(fecha_ini, '%Y-%m-%d')
                end = datetime.strptime(fecha_fin, '%Y-%m-%d')
                
                # Validación básica
                if start > end: return 0.0

                total_days = 0
                current = start
                
                # Iteramos día por día para verificar reglas
                while current <= end:
                    # current.weekday(): 0=Lunes, 6=Domingo
                    # REGLA DE NEGOCIO (Ejemplo): Si es Domingo (6), no cuenta.
                    # TODO: Conectar esto con la configuración de la Jornada real del empleado.
                    if current.weekday() < 5: 
                        total_days += 1
                    
                    current += timedelta(days=1)
                
                return float(total_days)
            
            # Caso 2: Por Horas (Mantiene tu lógica actual, que es correcta para horas intra-día)
            else:
                t_ini = datetime.strptime(hora_ini, '%H:%M')
                t_fin = datetime.strptime(hora_fin, '%H:%M')
                delta = t_fin - t_ini
                horas_totales = delta.total_seconds() / 3600
                
                if jornada_horas > 0:
                    return round(horas_totales / jornada_horas, 2)
                return 0.0
                
        except Exception as e:
            print(f"Error calculando tiempo: {e}")
            return 0.0
```

## Archivo: logics/vacation_service.py
```python
# logics/vacation_service.py
import sqlite3
from datetime import datetime, date, timedelta
from dateutil.relativedelta import relativedelta
from config.db_connection import DatabaseConnection


class VacationService:
    def __init__(self):
        self.db = DatabaseConnection()

    def process_monthly_accruals(self, id_contrato):
        """
        Calcula y guarda en BD solo hasta el mes cerrado ANTERIOR o ACTUAL (nunca futuro).
        """
        conn = self.db.get_connection()
        cursor = conn.cursor()
        
        try:
            # 1. Datos del contrato
            cursor.execute("SELECT fecha_inicio, fecha_inicio_kardex FROM contratos WHERE id_contrato = ?", (id_contrato,))
            row = cursor.fetchone()
            if not row or not row[1]: return 
            
            fecha_inicio_labores = datetime.strptime(row[0], '%Y-%m-%d').date()
            fecha_inicio_proceso = datetime.strptime(row[1], '%Y-%m-%d').date()
            
            hoy = date.today()
            current_date = fecha_inicio_proceso
            
            while True:
                # Calcular fin de mes
                next_month = current_date.replace(day=28) + timedelta(days=4)
                last_day_of_month = next_month - timedelta(days=next_month.day)
                
                # REGLA DE ORO: Si el fin de mes es mayor a HOY, paramos. No guardamos futuros.
                if last_day_of_month > hoy:
                    break
                
                # Validación de fechas históricas
                if last_day_of_month < fecha_inicio_proceso:
                    current_date = last_day_of_month + timedelta(days=1)
                    continue

                # Insertar en BD si no existe
                self._process_single_month(cursor, id_contrato, fecha_inicio_labores, last_day_of_month)
                
                current_date = last_day_of_month + timedelta(days=1)
            
            conn.commit()
            
        except Exception as e:
            print(f"Error VacationService: {e}")
            conn.rollback()
        finally:
            conn.close()

    def get_future_projections(self, id_contrato, target_date_str):
        """
        Calcula en MEMORIA (sin guardar en BD) las acumulaciones futuras.
        Retorna una lista de diccionarios con la simulación.
        """
        if not target_date_str: return []
        
        target_date = datetime.strptime(target_date_str, '%Y-%m-%d').date()
        hoy = date.today()
        
        # Si la fecha filtro es hoy o pasado, no hay proyección
        if target_date <= hoy: return []

        proyecciones = []
        conn = self.db.get_connection()
        cursor = conn.cursor()
        
        try:
            # Necesitamos fecha inicio para calcular antigüedad futura
            cursor.execute("SELECT fecha_inicio FROM contratos WHERE id_contrato = ?", (id_contrato,))
            row = cursor.fetchone()
            if not row: return []
            fecha_inicio_labores = datetime.strptime(row[0], '%Y-%m-%d').date()

            # Empezamos la proyección desde el primer mes futuro
            # Lógica rápida: Primer día del mes siguiente a hoy
            # (Asumiendo que process_monthly_accruals ya corrió hasta hoy)
            mes_actual = hoy.replace(day=28) + timedelta(days=4)
            fin_mes_actual = mes_actual - timedelta(days=mes_actual.day)
            
            # Si hoy es 17/12, el fin de mes es 31/12. Si 31/12 > 17/12 (True),
            # entonces el cierre de Diciembre es "Futuro". Empezamos a proyectar este mismo mes.
            # Si hoy fuera 31/12, Diciembre ya se guardó en BD. Proyectamos desde Enero.
            
            start_date = hoy
            
            current_date = start_date
            
            while True:
                # Calcular siguiente cierre de mes
                next_month = current_date.replace(day=28) + timedelta(days=4)
                last_day_of_month = next_month - timedelta(days=next_month.day)
                
                # Si nos pasamos de la fecha filtro seleccionada por el usuario, paramos
                if last_day_of_month > target_date:
                    break
                
                # Solo proyectamos fechas futuras a hoy
                if last_day_of_month > hoy:
                    # Cálculos Matemáticos (Idénticos al real)
                    antiguedad = relativedelta(last_day_of_month, fecha_inicio_labores)
                    anio_corriente = antiguedad.years + 1
                    
                    # Buscar Regla (Reutilizamos lógica o consulta rápida)
                    # Nota: Para optimizar, podrías cachear las reglas, aquí hacemos query simple
                    cursor.execute("SELECT dias_otorgar FROM cat_reglas_vacaciones WHERE anios_antiguedad = ?", (anio_corriente,))
                    res = cursor.fetchone()
                    if not res:
                         cursor.execute("SELECT dias_otorgar FROM cat_reglas_vacaciones ORDER BY anios_antiguedad DESC LIMIT 1")
                         res = cursor.fetchone()
                    
                    dias_anuales = res[0] if res else 15
                    dias_mensuales = dias_anuales / 12.0
                    
                    # Estructura Virtual (Simula lo que viene de BD)
                    proyecciones.append({
                        'fecha': last_day_of_month.strftime('%Y-%m-%d'),
                        'tipo': 'PROYECCION', # Etiqueta especial
                        'detalle': f"Proyección a {last_day_of_month.strftime('%Y-%m')} (Antigüedad: {antiguedad.years}a)",
                        'dias': dias_mensuales,
                        'es_virtual': True
                    })

                current_date = last_day_of_month + timedelta(days=1)
                
        finally:
            conn.close()
            
        return proyecciones

    def _process_single_month(self, cursor, id_contrato, fecha_inicio_labores, fecha_cierre):
        # ... (Este método se queda IGUAL que antes, contiene la lógica de INSERT real) ...
        # Solo asegúrate de copiarlo aquí si lo borraste
        periodo = fecha_cierre.strftime('%Y-%m')
        cursor.execute("""
            SELECT id_movimiento FROM kardex_vacaciones
            WHERE id_contrato = ? AND tipo_movimiento = 'ACUMULACION_MENSUAL'
            AND strftime('%Y-%m', fecha_movimiento) = ?
        """, (id_contrato, periodo))
        
        if cursor.fetchone(): return

        antiguedad = relativedelta(fecha_cierre, fecha_inicio_labores)
        anios_cumplidos = antiguedad.years
        anio_corriente = anios_cumplidos + 1
        
        cursor.execute("SELECT dias_otorgar FROM cat_reglas_vacaciones WHERE anios_antiguedad = ?", (anio_corriente,))
        res = cursor.fetchone()
        if not res:
            cursor.execute("SELECT dias_otorgar FROM cat_reglas_vacaciones ORDER BY anios_antiguedad DESC LIMIT 1")
            res = cursor.fetchone()
            
        dias_anuales = res[0] if res else 15
        dias_mensuales = dias_anuales / 12.0
        
        obs = f"Ganados en {periodo} (Antigüedad: {anios_cumplidos}a {antiguedad.months}m)"
        
        # Insertamos explícitamente como ORDINARIA
        cursor.execute("""
            INSERT INTO kardex_vacaciones 
            (id_contrato, fecha_movimiento, tipo_movimiento, dias, observacion, cuenta_tipo)
            VALUES (?, ?, 'ACUMULACION_MENSUAL', ?, ?, 'ORDINARIA')
        """, (id_contrato, fecha_cierre, dias_mensuales, obs))
```
